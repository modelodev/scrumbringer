# Story 3.0b: Time tracking / ongoing — limpieza total basada en sesiones (sin deprecaciones)

## Status: Draft

## Story
**As a** user,
**I want** to start/pause work sessions on any of my claimed tasks (including multiple tasks in parallel),
**so that** time tracking is accurate and consistent and the system can reliably show which tasks are being worked on right now.

## Acceptance Criteria
1. **Modelo único (sin deprecaciones)**: El sistema queda modelado exclusivamente con sesiones de trabajo como source of truth (ver Dev Notes). No quedan tablas/patrones antiguos conviviendo para “Now Working/ongoing” o acumulados.
2. **Multi-ongoing por usuario**: Un usuario puede tener **0..N** tareas “en curso” simultáneamente.
3. **Ongoing por tarea (quién está trabajando)**:
   - Una tarea puede tener como máximo **1** sesión activa en un momento dado.
   - El sistema expone quién está trabajando ahora en la tarea (si existe sesión activa).
4. **Claim invariants (negocio cerrado)**:
   - Una tarea solo puede estar claimed por **1** usuario.
   - Solo el **claimer** puede iniciar (start) una sesión de trabajo para esa tarea.
5. **Invariante completed**:
   - Una tarea `completed` no puede tener sesiones activas.
   - Al completar una tarea, el sistema garantiza que no hay sesión activa para esa task (la cierra / la rechaza según endpoint; ver Tasks).
6. **Cómputo de tiempos**:
   - Se persiste el tiempo por `(user_id, task_id)` (acumulado total, en segundos).
   - Se expone el total por task (suma por usuarios; en este modelo debería coincidir con el claimer, pero se mantiene el shape por consistencia y futuro).
7. **Heartbeat + stale cutoff**:
   - Mientras una sesión esté activa, el cliente envía `heartbeat` cada 60s.
   - Si no hay heartbeat por un umbral (stale cutoff), el servidor considera la sesión como “stale” y la cierra (o la marca como ended) de forma determinista para mantener consistencia.
8. **API Contract (JSON) actualizado**:
   - Existe un set de endpoints para listar/gestionar sesiones activas y tiempos acumulados.
   - El contrato representa (a) lista de sesiones activas del usuario y (b) estado ongoing por tarea con `ongoing_by`.
9. **UX mínima**:
   - “Now Working” soporta múltiples entradas (lista) y permite `start/pause` por tarea.
10. **Migración de datos**:
   - Se migran datos existentes desde el modelo previo (`user_now_working`, `user_task_now_working_time`) al nuevo modelo por sesiones, manteniendo el acumulado.
11. **Testing**:
   - Server: pruebas cubren invariantes (claimer-only, completed => no active, multi-ongoing por usuario, single ongoing por task), y migración.
   - Client: decode del nuevo payload y rendering básico de lista “Now Working”.

## Tasks / Subtasks
- [ ] Task 1: Definir nuevo data model basado en sesiones (AC: 1–7)
  - [ ] Crear tabla `user_task_work_session` (source of truth)
    - [ ] Campos mínimos: `id`, `user_id`, `task_id`, `started_at`, `last_heartbeat_at`, `ended_at` (nullable), `ended_reason` (nullable), `created_at`
    - [ ] Constraints/índices:
      - [ ] Garantizar **máx 1 sesión activa por task** (p.ej. unique index parcial `WHERE ended_at IS NULL`)
      - [ ] Garantizar **máx 1 sesión activa por (user, task)** (evita duplicados)
      - [ ] Índices para queries: por `user_id`, por `task_id`, por `ended_at IS NULL`
  - [ ] Crear tabla de acumulados `user_task_work_total` (cache/materialización) o vista materializada
    - [ ] PK `(user_id, task_id)` + `accumulated_s`, `updated_at`
    - [ ] Regla: `accumulated_s >= 0`
  - [ ] (Opcional, si es necesario para performance) Crear vista/consulta para `task_total_s` (sum de `user_task_work_total` por `task_id`)

- [ ] Task 2: Migración DB (drop-in) sin convivencia de modelos (AC: 1, 10)
  - [ ] Añadir migración dbmate que:
    - [ ] Crea nuevas tablas/índices
    - [ ] Migra datos desde `user_task_now_working_time` → `user_task_work_total`
    - [ ] Migra sesiones activas desde `user_now_working` → `user_task_work_session` (crear sesiones activas con `started_at` existente y `last_heartbeat_at = updated_at`)
    - [ ] Elimina tablas antiguas: `user_now_working`, `user_task_now_working_time`
  - [ ] Validar migración en DB vacía y con fixtures

- [ ] Task 3: Reglas de negocio + transacciones (AC: 2–7)
  - [ ] `start_work_session(user_id, task_id)`
    - [ ] Rechaza si la task no está `claimed` por el usuario (`409 CONFLICT_CLAIMED`)
    - [ ] Rechaza si la task está `completed` (`409` con código nuevo o `CONFLICT_INVALID_STATE` si existe; si no, definir uno siguiendo `docs/architecture/api-contract.md`)
    - [ ] Garantiza atomicidad: crear sesión activa o devolver estado actual sin duplicar
  - [ ] `pause_work_session(user_id, task_id)`
    - [ ] Cierra sesión activa (si existe) y actualiza acumulado
    - [ ] Idempotente (pausar cuando no hay sesión activa para esa task devuelve OK)
  - [ ] `heartbeat_work_session(user_id, task_id)`
    - [ ] Actualiza `last_heartbeat_at`
    - [ ] Opcional: “flush” incremental del acumulado (según diseño) para no depender de pause
  - [ ] `close_stale_sessions(now)`
    - [ ] Define cutoff (p.ej. 2–5 min) y cierra sesiones con `last_heartbeat_at < now - cutoff`
    - [ ] Razón: `stale_timeout`
  - [ ] Integración con `complete` y `release` (invariante completed)
    - [ ] Antes de `complete`: cerrar sesión activa (si existe) y flush de acumulado
    - [ ] Antes de `release`: cerrar sesión activa (si existe) y flush

- [ ] Task 4: API endpoints nuevos/actualizados (AC: 8)
  - [ ] Reemplazar contrato anterior “single active task” por lista
  - [ ] Endpoints propuestos (base `/api/v1`):
    - [ ] `GET /me/work-sessions/active` → `200 { data: { active_sessions: List(ActiveWorkSession), as_of: ISO8601 } }`
    - [ ] `POST /me/work-sessions/start` body `{ task_id: Int }` → mismo payload
    - [ ] `POST /me/work-sessions/pause` body `{ task_id: Int }` → mismo payload
    - [ ] `POST /me/work-sessions/heartbeat` body `{ task_id: Int }` → mismo payload
  - [ ] Ajustar payload de Task (en endpoints que devuelven tasks) para exponer ongoing por tarea:
    - [ ] Añadir `task.ongoing_by: { user_id: Int } | null`
    - [ ] Añadir `task.work_state: "available" | "claimed" | "ongoing" | "completed"` derivado (opcional pero recomendado)

- [ ] Task 5: Client UX mínima “Now Working” como lista (AC: 9, 11)
  - [ ] UI: renderizar lista de sesiones activas
  - [ ] Acciones por ítem: start/pause/complete/release
  - [ ] Timer por sesión: `elapsed_total_s = accumulated_s + seconds(as_of - started_at)`
  - [ ] Heartbeat: mientras una sesión esté activa, enviar heartbeat cada 60s por task activa

- [ ] Task 6: Tests (AC: 11)
  - [ ] Server:
    - [ ] Multi-ongoing por usuario (start en tasks A y B claimed por user) => 2 sesiones activas
    - [ ] Single ongoing por task (si ya hay sesión activa para task, no permite segunda) => `409`
    - [ ] Only claimer can start => `409 CONFLICT_CLAIMED`
    - [ ] Completed => start rejected; complete cierra sesión activa
    - [ ] Heartbeat + stale cutoff cierra sesión
    - [ ] Migración: acumulados preservados y sesión activa migrada
  - [ ] Client:
    - [ ] Decode de `active_sessions` payload
    - [ ] Render lista: 0/1/N elementos sin crash

## Dev Notes
### Business rules (cerradas)
- Un usuario puede trabajar en **0..N** tareas a la vez. [Source: docs/brief.md]
- Una tarea solo puede estar claimed por **1** usuario. [Source: docs/architecture/data-model.md#Task]

### Modelo actual (a limpiar)
- `tasks.status`: `available|claimed|completed`. [Source: docs/architecture/data-model.md#Task]
- Estado personal previo:
  - Tabla `user_now_working` (1 fila por usuario) con `task_id`, `project_id`, `started_at`. [Source: db/migrations/20260114231500_create_user_now_working.sql]
  - Acumulado previo: `user_task_now_working_time (user_id, task_id, accumulated_s)`. [Source: db/migrations/20260115223000_create_user_task_now_working_time.sql]
- Nota: el brief original decía 0..1 activa; esto se actualiza para permitir 0..N. [Source: docs/brief.md]

### Nuevo modelo recomendado (source of truth)
- Introducir `user_task_work_session` como **única** fuente de verdad de “ongoing” y time tracking.
  - Sesión activa: `ended_at IS NULL`.
  - `ongoing` por task se deriva de “existe sesión activa para task”.
  - `work_state` se deriva de `tasks.status` + “ongoing por sesión activa” (ongoing ⇒ claimed).

### Invariantes (no negociables)
- `completed` ⇒ no ongoing (no sesiones activas).
- Ongoing ⇒ task `claimed`.
- Only claimer can start work.
- Máx 1 sesión activa por task.

### API Contract / JSON
- Conventions: response envelope `{ "data": ... }`, timestamps ISO-8601 UTC, y conflictos `409`. [Source: docs/architecture/api-contract.md]
- Nuevo payload para sesiones activas:

```json
{
  "data": {
    "active_sessions": [
      {
        "task_id": 123,
        "started_at": "2026-01-16T12:00:00Z",
        "accumulated_s": 420,
        "as_of": "2026-01-16T12:10:00Z"
      }
    ],
    "as_of": "2026-01-16T12:10:00Z"
  }
}
```

- En Task payload (cuando aplique):

```json
{
  "id": 123,
  "status": "claimed",
  "claimed_by": 42,
  "work_state": "ongoing",
  "ongoing_by": { "user_id": 42 }
}
```

### UX mínima
- Desktop: “Now Working” pasa de 1 tarjeta a lista.
- Mobile: sigue sin Pool; muestra My Bar + lista Now Working.

## Testing
- Server: `make test` / `make verify`
- Client: `cd apps/client && gleam test`

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2026-01-16 | 0.1 | Draft story: clean time tracking model with work sessions | po |

## Dev Agent Record

## QA Results
