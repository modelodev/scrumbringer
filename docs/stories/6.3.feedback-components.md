# Story 6.3: Extensión de Componentes de Feedback UX

## Status

Done

## Story

**As a** usuario de ScrumBringer,
**I want** spinners de carga animados en botones y mensajes de error inline en formularios,
**so that** tenga feedback visual claro durante operaciones y entienda errores de validación.

## Problem Statement

La auditoría UI (Score: 68/100) identificó carencias en feedback visual:

1. **Sin spinner animado**: `ui/loading.gleam` solo muestra texto, no spinner visual.
2. **Errores de formulario sin ubicación**: No hay componente de error inline por campo.
3. **Botones sin estado loading**: Algunos botones fuera de `dialog.submit_button` no muestran loading.

**IMPORTANTE - Componentes que YA EXISTEN (NO recrear):**
- `ui/toast.gleam` - Sistema completo de notificaciones con ToastVariant, ToastState, auto-dismiss
- `ui/confirm_dialog.gleam` - Modal de confirmación con ConfirmConfig, is_loading, danger/primary
- `UiModel.toast_state` - Ya integrado en el Model
- `ToastShow`, `ToastDismiss`, `ToastTick` - Ya integrados en Msg
- `view_global_overlays()` - Ya renderiza toast container

Esta historia EXTIENDE componentes existentes, NO crea duplicados.

---

## Acceptance Criteria

1. `ui/loading.gleam` tiene nueva función `spinner(size: SpinnerSize)` con tamaños Small/Medium/Large.
2. `ui/form_field.gleam` tiene nueva función `with_error(label, control, error: Option(String))`.
3. Los errores de formulario inline muestran icono de warning y tienen `role="alert"`.
4. Los botones de submit fuera de dialogs pueden mostrar spinner cuando están cargando.
5. (P2 Opcional) Existe `ui/skeleton.gleam` con `skeleton_line()` y `skeleton_card()`.
6. Todos los componentes extendidos tienen tests unitarios.
7. Los cambios siguen los patrones idiomáticos del proyecto (ADTs, Option, funciones puras).

---

## Tasks / Subtasks

- [x] **Task 1: Extender loading.gleam con spinner animado** (AC: 1)
  - [x] 1.1 Añadir tipo `SpinnerSize { Small, Medium, Large }` a `ui/loading.gleam`.
  - [x] 1.2 Implementar `spinner(size: SpinnerSize) -> Element(msg)` con clase `animate-spin`.
  - [x] 1.3 Añadir estilos CSS para `.spinner-sm`, `.spinner-md`, `.spinner-lg` en `styles.gleam`.
  - [x] 1.4 Test: verificar que spinner genera elemento con clase correcta por tamaño.

- [x] **Task 2: Extender form_field.gleam con soporte de error** (AC: 2, 3)
  - [x] 2.1 Añadir función `with_error(label: String, control: Element(msg), error: Option(String))`.
  - [x] 2.2 Renderizar error con `role="alert"` y icono de warning cuando `error = Some(msg)`.
  - [x] 2.3 Usar clase `.field-error` con colores red-600/red-500.
  - [x] 2.4 Test: verificar que with_error genera elemento con role="alert".

- [x] **Task 2b: Integración de with_error en formularios con errores inline** (AC: 2, 3)
  - [x] 2b.1 `features/auth/view.gleam` L255-269: Migrar password accept invite.
    - Actualmente: `form_field.view()` + `case password_error { ... error_notice.view(err) ... }` separado.
    - Migrar a: `form_field.with_error(label, input, password_error)`.
  - [x] 2b.2 `features/auth/view.gleam` L354-368: Migrar password reset.
    - Mismo patrón: eliminar case manual y usar `form_field.with_error()`.
  - [x] 2b.3 Verificar visualmente que errores inline aparecen correctamente.
  - [ ] NOTA: Los errores a nivel de formulario (login_error, create_error) se muestran correctamente
    con `error_notice.view()` o `dialog.view(..., error, ...)`. NO cambiar esos.

- [x] **Task 3: CSS para spinner animado en clase btn-loading** (AC: 4)
  - [x] 3.1 Añadir CSS spinner animado a clase `.btn-loading` en `styles.gleam`.
  - [x] 3.2 El spinner debe aparecer automáticamente en botones con clase `btn-loading`.
  - [x] 3.3 Test: verificar que `.btn-loading` muestra spinner animado.
  - [ ] NOTA: La mayoría de botones YA usan `btn-loading` class cuando `*_in_flight = True`:
    - `auth/view.gleam` L104-111: Login submit (btn-loading)
    - `admin/views/members.gleam` L387-405: Add member submit (btn-loading)
    - `admin/views/members.gleam` L570-588: Capabilities save (btn-loading)
    - `pool/dialogs.gleam` L158-174: Create task submit (btn-loading)
    - `card_crud_dialog.gleam` L676-692: Create card submit (btn-loading)
    - El problema es que NO hay spinner CSS animado, solo cambio de texto.

- [x] **Task 3b: Añadir btn-loading a botones que faltan** (AC: 4)
  - [x] 3b.1 `features/auth/view.gleam` L161-166: Forgot password submit - añadir `btn-loading` class.
  - [x] 3b.2 `features/auth/view.gleam` L274: Accept invite submit - añadir `btn-loading` class.
  - [x] 3b.3 `features/auth/view.gleam` L373: Reset password submit - añadir `btn-loading` class.
  - [x] 3b.4 Verificar visualmente que spinners aparecen en todos los botones de submit.

- [x] **Task 4: Skeleton (Opcional P2)** (AC: 5)
  - [x] 4.1 Crear `apps/client/src/scrumbringer_client/ui/skeleton.gleam`.
  - [x] 4.2 Implementar `skeleton_line(width: String, height: String)` con clase `animate-pulse`.
  - [x] 4.3 Implementar `skeleton_card()` para placeholder de tarjetas.
  - [x] 4.4 Añadir documentación de módulo (Mission, Responsibilities, Relations).
  - [x] 4.5 Test: verificar que skeleton tiene clase animate-pulse.

- [x] **Task 5: Tests de regresión** (AC: 6, 7)
  - [x] 5.1 Ejecutar suite de tests existente.
  - [x] 5.2 Verificar que cambios a loading.gleam y form_field.gleam no rompen usos existentes.

---

## Dev Notes

### CRÍTICO: NO duplicar componentes existentes

El proyecto YA TIENE implementados y funcionando:

```
ui/toast.gleam         → Sistema de notificaciones COMPLETO
ui/confirm_dialog.gleam → Modal de confirmación COMPLETO  
ui/dialog.gleam        → submit_button() con is_loading COMPLETO
```

**ESTOS NO DEBEN MODIFICARSE NI RECREARSE.**

### Archivos a EXTENDER

```
apps/client/src/scrumbringer_client/ui/
├── loading.gleam      # EXTENDER con spinner(size)
├── form_field.gleam   # EXTENDER con with_error()
├── action_buttons.gleam # YA EXISTE - no necesita modificaciones para esta historia
└── skeleton.gleam     # CREAR NUEVO (P2, opcional)

apps/client/src/scrumbringer_client/
└── styles.gleam       # MODIFICAR - añadir CSS para .spinner, .btn-loading, .field-error
```

### Patrones idiomáticos a seguir

**ADT para SpinnerSize (exhaustivo sin wildcard):**
```gleam
pub type SpinnerSize {
  Small   // 16px
  Medium  // 24px
  Large   // 32px
}

pub fn spinner(size: SpinnerSize) -> Element(msg) {
  let size_class = case size {
    Small -> "spinner-sm"
    Medium -> "spinner-md"
    Large -> "spinner-lg"
  }
  div([class("spinner " <> size_class)], [])
}
```

**Option para error (no string vacío):**
```gleam
pub fn with_error(
  label_text: String,
  control: Element(msg),
  error: Option(String),
) -> Element(msg) {
  div([class("field")], [
    label([], [text(label_text)]),
    control,
    case error {
      opt.Some(msg) -> 
        div([class("field-error"), attribute.role("alert")], [
          span([class("error-icon")], [text("⚠")]),
          text(msg),
        ])
      opt.None -> element.none()
    }
  ])
}
```

**Documentación de módulo (skeleton.gleam nuevo):**
```gleam
//// Skeleton loading placeholders.
////
//// ## Mission
////
//// Provide animated placeholder UI during content loading.
////
//// ## Responsibilities
////
//// - Render skeleton lines and shapes with pulse animation
////
//// ## Non-responsibilities
////
//// - State management (caller handles Remote state)
////
//// ## Relations
////
//// - **data_table.gleam**: Can use skeleton for loading state
//// - **Remote type**: Complements Loading variant rendering
```

### CSS a añadir en styles.gleam

```css
/* Spinner animation */
.spinner {
  border: 2px solid var(--sb-border);
  border-top-color: var(--sb-primary);
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}
.spinner-sm { width: 16px; height: 16px; }
.spinner-md { width: 24px; height: 24px; }
.spinner-lg { width: 32px; height: 32px; }

/* Spinner en botones con btn-loading */
.btn-loading::after {
  content: "";
  display: inline-block;
  width: 14px;
  height: 14px;
  margin-left: 0.5rem;
  border: 2px solid currentColor;
  border-top-color: transparent;
  border-radius: 50%;
  animation: spin 0.6s linear infinite;
}

@keyframes spin {
  to { transform: rotate(360deg); }
}

/* Field error */
.field-error {
  color: var(--sb-error);
  font-size: 0.875rem;
  margin-top: 0.25rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

/* Skeleton */
.skeleton {
  background: var(--sb-muted);
  border-radius: 4px;
  animation: pulse 1.5s ease-in-out infinite;
}

@keyframes pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.5; }
}
```

### Análisis de errores inline vs errores de formulario

Hay dos patrones de error en el proyecto:

1. **Errores de submit/formulario** (se muestran encima del form con `error_notice.view()`):
   - `login_error`, `forgot_password_error` - error de API
   - `create_error`, `edit_error`, `delete_error` - error de operación CRUD
   - `submit_error` en accept_invite y reset_password
   - Estos NO deben moverse a inline

2. **Errores de validación de campo** (se muestran junto al campo específico):
   - `password_error` en accept_invite y reset_password - validación de longitud mínima
   - Actualmente renderizados manualmente con `error_notice.view(err)` después del campo
   - Estos SÍ deben migrar a `form_field.with_error()`

### Análisis de btn-loading existente

| Archivo | Línea | Botón | Tiene btn-loading | Acción |
|---------|-------|-------|-------------------|--------|
| `auth/view.gleam` | L104-111 | Login submit | SÍ (L108) | Solo añadir CSS spinner |
| `auth/view.gleam` | L161-166 | Forgot password | NO | AÑADIR btn-loading |
| `auth/view.gleam` | L274 | Accept invite | NO | AÑADIR btn-loading |
| `auth/view.gleam` | L373 | Reset password | NO | AÑADIR btn-loading |
| `admin/members.gleam` | L387-405 | Add member | SÍ (L394-396) | Solo CSS |
| `admin/members.gleam` | L570-588 | Capabilities save | SÍ (L577-579) | Solo CSS |
| `pool/dialogs.gleam` | L158-174 | Create task | SÍ (L163-165) | Solo CSS |
| `card_crud_dialog.gleam` | L676-692 | Create card | SÍ (L681-684) | Solo CSS |

---

## Testing

### ⚠️ METODOLOGÍA: TDD OBLIGATORIO

**Proceso para cada Task:**
1. PRIMERO escribir los tests (RED)
2. Ejecutar tests y verificar que fallan
3. Implementar el código mínimo para pasar (GREEN)
4. Refactorizar si es necesario (REFACTOR)
5. Repetir para siguiente subtask

### Test Standards

- Tests en `apps/client/test/`
- Framework: `gleeunit`
- Convención: funciones terminan en `_test`
- Ejecutar: `cd apps/client && gleam test`
- Patrón: `element.to_document_string()` + `string.contains()` para verificar HTML

### Test Files a Crear/Modificar

```
apps/client/test/
├── ui_loading_test.gleam         # CREAR - tests para spinner()
├── ui_form_field_test.gleam      # CREAR/MODIFICAR - tests para with_error()
├── ui_skeleton_test.gleam        # CREAR - tests para skeleton (P2)
└── styles_btn_loading_test.gleam # CREAR - tests para CSS btn-loading
```

### Test Cases Detallados

#### Task 1: loading.spinner() - Archivo: `ui_loading_test.gleam`

**Happy Path:**
```gleam
pub fn spinner_small_has_correct_class_test() {
  let rendered = loading.spinner(loading.Small)
  let html = element.to_document_string(rendered)
  string.contains(html, "spinner") |> should.be_true
  string.contains(html, "spinner-sm") |> should.be_true
}

pub fn spinner_medium_has_correct_class_test() {
  let rendered = loading.spinner(loading.Medium)
  let html = element.to_document_string(rendered)
  string.contains(html, "spinner-md") |> should.be_true
}

pub fn spinner_large_has_correct_class_test() {
  let rendered = loading.spinner(loading.Large)
  let html = element.to_document_string(rendered)
  string.contains(html, "spinner-lg") |> should.be_true
}
```

**Casos Comunes:**
```gleam
pub fn spinner_is_empty_element_test() {
  // Spinner no debe tener contenido de texto (es puro CSS)
  let rendered = loading.spinner(loading.Small)
  let html = element.to_document_string(rendered)
  // Debe ser algo como <div class="spinner spinner-sm"></div>
  string.contains(html, "><") |> should.be_true  // Empty element
}

pub fn spinner_all_sizes_render_without_crash_test() {
  // Verificar que todos los tamaños se pueden renderizar
  [loading.Small, loading.Medium, loading.Large]
  |> list.each(fn(size) {
    let rendered = loading.spinner(size)
    let html = element.to_document_string(rendered)
    string.length(html) |> should.not_equal(0)
  })
}
```

**Casos Edge/Esporádicos:**
```gleam
pub fn spinner_size_enum_is_exhaustive_test() {
  // Este test documenta que SpinnerSize tiene exactamente 3 variantes
  // Si se añade una variante, el pattern match en spinner() debe actualizarse
  let sizes = [loading.Small, loading.Medium, loading.Large]
  list.length(sizes) |> should.equal(3)
}

pub fn loading_function_still_works_test() {
  // Verificar que la función existente loading() no se rompió
  let rendered = loading.loading("Cargando...")
  let html = element.to_document_string(rendered)
  string.contains(html, "Cargando...") |> should.be_true
  string.contains(html, "loading") |> should.be_true
}

pub fn loading_panel_still_works_test() {
  // Verificar que loading_panel() existente sigue funcionando
  let rendered = loading.loading_panel("Título", "Mensaje")
  let html = element.to_document_string(rendered)
  string.contains(html, "Título") |> should.be_true
  string.contains(html, "Mensaje") |> should.be_true
}
```

#### Task 2: form_field.with_error() - Archivo: `ui_form_field_test.gleam`

**Happy Path:**
```gleam
pub fn with_error_shows_error_when_some_test() {
  let rendered = form_field.with_error(
    "Password",
    input([]),
    Some("La contraseña es muy corta"),
  )
  let html = element.to_document_string(rendered)
  string.contains(html, "La contraseña es muy corta") |> should.be_true
  string.contains(html, "field-error") |> should.be_true
}

pub fn with_error_has_role_alert_test() {
  let rendered = form_field.with_error("Email", input([]), Some("Email inválido"))
  let html = element.to_document_string(rendered)
  string.contains(html, "role=\"alert\"") |> should.be_true
}

pub fn with_error_hides_error_when_none_test() {
  let rendered = form_field.with_error("Email", input([]), None)
  let html = element.to_document_string(rendered)
  string.contains(html, "field-error") |> should.be_false
  string.contains(html, "role=\"alert\"") |> should.be_false
}
```

**Casos Comunes:**
```gleam
pub fn with_error_preserves_label_test() {
  let rendered = form_field.with_error("Contraseña", input([]), Some("Error"))
  let html = element.to_document_string(rendered)
  string.contains(html, "Contraseña") |> should.be_true
}

pub fn with_error_preserves_control_test() {
  let rendered = form_field.with_error(
    "Test",
    input([attribute.id("my-input")]),
    None,
  )
  let html = element.to_document_string(rendered)
  string.contains(html, "my-input") |> should.be_true
}

pub fn with_error_shows_warning_icon_test() {
  let rendered = form_field.with_error("Test", input([]), Some("Error"))
  let html = element.to_document_string(rendered)
  // Debe tener icono de warning (⚠ o clase de icono)
  let has_icon = 
    string.contains(html, "⚠") ||
    string.contains(html, "error-icon") ||
    string.contains(html, "warning")
  has_icon |> should.be_true
}
```

**Casos Edge/Esporádicos:**
```gleam
pub fn with_error_empty_string_error_still_shows_test() {
  // Some("") es diferente de None - debe mostrar el contenedor de error
  let rendered = form_field.with_error("Test", input([]), Some(""))
  let html = element.to_document_string(rendered)
  string.contains(html, "field-error") |> should.be_true
}

pub fn with_error_html_in_error_is_escaped_test() {
  // XSS prevention: HTML en el mensaje de error se escapa
  let rendered = form_field.with_error(
    "Test",
    input([]),
    Some("<script>alert('xss')</script>"),
  )
  let html = element.to_document_string(rendered)
  string.contains(html, "&lt;script&gt;") |> should.be_true
  string.contains(html, "<script>") |> should.be_false
}

pub fn with_error_long_error_message_renders_test() {
  // Mensajes de error largos no rompen el layout
  let long_msg = "Este es un mensaje de error muy largo que podría 
    causar problemas de layout si no se maneja correctamente en el CSS"
  let rendered = form_field.with_error("Test", input([]), Some(long_msg))
  let html = element.to_document_string(rendered)
  string.contains(html, "muy largo") |> should.be_true
}

pub fn with_error_unicode_error_message_test() {
  // Mensajes con unicode (español, emojis)
  let rendered = form_field.with_error(
    "Test",
    input([]),
    Some("Contraseña inválida ❌"),
  )
  let html = element.to_document_string(rendered)
  string.contains(html, "Contraseña inválida") |> should.be_true
}

pub fn view_and_with_error_produce_same_structure_when_no_error_test() {
  // with_error(label, control, None) debe ser similar a view(label, control)
  let normal = form_field.view("Email", input([]))
  let with_err = form_field.with_error("Email", input([]), None)
  
  let html_normal = element.to_document_string(normal)
  let html_with_err = element.to_document_string(with_err)
  
  // Ambos deben tener la estructura básica
  string.contains(html_normal, "field") |> should.be_true
  string.contains(html_with_err, "field") |> should.be_true
}
```

#### Task 3: CSS btn-loading - Archivo: `styles_btn_loading_test.gleam`

**Nota**: Estos tests verifican que los elementos Gleam generan las clases correctas.
La verificación visual del spinner CSS es manual o con Playwright.

```gleam
pub fn button_with_loading_class_test() {
  // Verificar que podemos generar un botón con clase btn-loading
  let rendered = html.button(
    [attribute.class("btn-loading"), attribute.disabled(True)],
    [text("Cargando...")],
  )
  let html_str = element.to_document_string(rendered)
  string.contains(html_str, "btn-loading") |> should.be_true
}

pub fn button_without_loading_class_test() {
  // Verificar que botón normal no tiene la clase
  let rendered = html.button(
    [attribute.class("")],
    [text("Enviar")],
  )
  let html_str = element.to_document_string(rendered)
  string.contains(html_str, "btn-loading") |> should.be_false
}
```

#### Task 4: skeleton.gleam (P2 Opcional) - Archivo: `ui_skeleton_test.gleam`

**Happy Path:**
```gleam
pub fn skeleton_line_has_skeleton_class_test() {
  let rendered = skeleton.skeleton_line("100%", "16px")
  let html = element.to_document_string(rendered)
  string.contains(html, "skeleton") |> should.be_true
}

pub fn skeleton_line_has_dimensions_test() {
  let rendered = skeleton.skeleton_line("200px", "20px")
  let html = element.to_document_string(rendered)
  // Debe tener estilos inline o clases para dimensiones
  string.contains(html, "200px") |> should.be_true
  string.contains(html, "20px") |> should.be_true
}

pub fn skeleton_card_has_skeleton_class_test() {
  let rendered = skeleton.skeleton_card()
  let html = element.to_document_string(rendered)
  string.contains(html, "skeleton") |> should.be_true
}
```

**Casos Comunes:**
```gleam
pub fn skeleton_line_with_percentage_width_test() {
  let rendered = skeleton.skeleton_line("50%", "1rem")
  let html = element.to_document_string(rendered)
  string.contains(html, "50%") |> should.be_true
}

pub fn skeleton_line_with_rem_units_test() {
  let rendered = skeleton.skeleton_line("10rem", "1.5rem")
  let html = element.to_document_string(rendered)
  string.contains(html, "10rem") |> should.be_true
}
```

**Casos Edge:**
```gleam
pub fn skeleton_line_empty_dimensions_test() {
  // Dimensiones vacías no crashean
  let rendered = skeleton.skeleton_line("", "")
  let html = element.to_document_string(rendered)
  string.contains(html, "skeleton") |> should.be_true
}

pub fn skeleton_line_invalid_dimensions_still_renders_test() {
  // Valores inválidos CSS no crashean (browser los ignora)
  let rendered = skeleton.skeleton_line("invalid", "also-invalid")
  let html = element.to_document_string(rendered)
  string.length(html) |> should.not_equal(0)
}
```

### Tests de Regresión

```gleam
// Archivo: ui_loading_regression_test.gleam

pub fn existing_loading_function_unchanged_test() {
  // La función loading() existente sigue funcionando igual
  let rendered = loading.loading("Test message")
  let html = element.to_document_string(rendered)
  string.contains(html, "Test message") |> should.be_true
  string.contains(html, "class=\"loading\"") |> should.be_true
}

pub fn existing_loading_panel_unchanged_test() {
  // La función loading_panel() existente sigue funcionando
  let rendered = loading.loading_panel("Title", "Message")
  let html = element.to_document_string(rendered)
  string.contains(html, "Title") |> should.be_true
  string.contains(html, "Message") |> should.be_true
  string.contains(html, "panel") |> should.be_true
}
```

### Tests de Integración (Playwright)

Para verificación visual del CSS spinner animado:

```javascript
// /tmp/test-btn-loading-spinner.js
const { chromium } = require('playwright');

(async () => {
  const browser = await chromium.launch({ headless: true });
  const page = await browser.newPage();
  
  // Navegar a login
  await page.goto('http://localhost:8080/login');
  
  // Llenar form
  await page.fill('input[type="email"]', 'admin@example.com');
  await page.fill('input[type="password"]', 'wrongpassword');
  
  // Capturar estado normal del botón
  await page.screenshot({ path: '/tmp/btn-normal.png' });
  
  // Click submit y capturar estado loading
  await page.click('button[type="submit"]');
  await page.waitForTimeout(100); // Capturar durante loading
  await page.screenshot({ path: '/tmp/btn-loading.png' });
  
  // Verificar que el botón tiene clase btn-loading
  const btnClass = await page.$eval(
    'button[type="submit"]',
    el => el.className
  );
  console.log('Button class during loading:', btnClass);
  
  await browser.close();
})();
```

---

## Out of Scope

- Modificar `ui/toast.gleam` (ya completo)
- Modificar `ui/confirm_dialog.gleam` (ya completo)
- Modificar `ui/dialog.gleam` (ya completo)
- Cambios de estado en Model para toast (ya existe)
- Auto-dismiss de toasts (ya implementado)

---

## Change Log

| Fecha | Version | Descripcion | Autor |
|-------|---------|-------------|-------|
| 2026-02-03 | 1.0 | Historia creada desde UI Audit Plan - Fase 2 | PO |
| 2026-02-03 | 2.0 | Reescrita por Arquitecto: eliminar duplicados, enfocar en extensiones | Architect |
| 2026-02-03 | 3.0 | Spinner, inline errors, btn-loading y skeleton implementados con tests | dev |

---

## Dev Agent Record

### Agent Model Used

openai/gpt-5.2-codex

### Debug Log References

- `gleam test`

### Completion Notes List

- Added spinner sizes in loading UI and CSS helpers.
- Added form_field.with_error with inline alert rendering and integrated it in auth flows.
- Added btn-loading class to missing submit buttons and introduced skeleton placeholders.
- Added/updated tests for spinner, with_error, skeleton, and btn-loading.

### File List

- apps/client/src/scrumbringer_client/ui/loading.gleam
- apps/client/src/scrumbringer_client/ui/form_field.gleam
- apps/client/src/scrumbringer_client/ui/skeleton.gleam
- apps/client/src/scrumbringer_client/features/auth/view.gleam
- apps/client/src/scrumbringer_client/styles.gleam
- apps/client/test/ui_loading_test.gleam
- apps/client/test/ui_form_field_test.gleam
- apps/client/test/styles_btn_loading_test.gleam
- apps/client/test/ui_skeleton_test.gleam

---

## QA Results

### Review Date: 2026-02-03

### Reviewed By: Quinn (Test Architect)

### Code Quality Assessment

La extension de `loading`, `form_field`, y `skeleton` mantiene patrones idiomaticos (ADT + Option) y la integracion en auth views respeta los flujos existentes. La CSS para `.spinner` y `.btn-loading` resuelve el feedback visual sin introducir logica nueva. Tests verificados con `gleam test` (558 passed).

### Refactoring Performed

- None.

### Compliance Check

- Coding Standards: ✓
- Project Structure: ✓
- Testing Strategy: ✓ (gleam test)
- All ACs Met: ✓ (AC5 opcional implementado)

### Improvements Checklist

- [x] No changes required.

### Security Review

Mensajes de error se renderizan via `text(...)`, evitando inyeccion HTML; `role="alert"` presente en errores inline.

### Performance Considerations

Spinners y skeletons son CSS-only; impacto de rendimiento minimo.

### Files Modified During Review

- None.

### Gate Status

Gate: PASS → docs/qa/gates/6.3-extension-de-componentes-de-feedback-ux.yml
Risk profile: docs/qa/assessments/6.3-risk-20260203.md
NFR assessment: docs/qa/assessments/6.3-nfr-20260203.md

### Recommended Status

[✓ Ready for Done] / [✗ Changes Required - See unchecked items above]
(Story owner decides final status)
